# Unauthorized Transfer in ReptilianCoin

## Vendor
Ethereum blockchain

## Vulnerability Type
Incorrect Access Control

## Abstract
The Ethereum smart contract ReptilianCoin (RPTC) was found to have an incorrect access control vulnerability. The contract does not correctly check the status of the `tradingOpen`, `limited`, `maxHoldingAmount`, and `inHoldingAmount` variables, allowing unauthorized transfer operations when trading is not permitted. This can lead to unexpected behavior and potential loss of assets.

## Details

Contract `ReptilianCoin` contains a `startTrading` function that can set `tradingOpen` to true. However, there is no check on the state of `tradingOpen` in the contract. This may allow users to still perform transfer operations when trading is not permitted. 

```solidity
contract ReptilianCoin {
  ...
  bool tradingOpen = false;
  function startTrading() public onlyOwner {
    tradingOpen = true;
  }
  ...
  function _transfer(address from, address to, uint256 amount) internal {
    require(from != address(0));
    require(amount <= _balances[from]);
    uint256 tax = amount.mul(getFee(from, to)).div(100); 
    emit Transfer(from, to, amount);
    _balances[to] = _balances[to] + amount - tax;
    _balances[from] = _balances[from] - amount;
  }
  ...
}
```

The attack process is as follows:

**Step 1** An attacker calls the `_transfer` function directly or indirectly (through other functions that call `_transfer`), attempting to perform a transfer operation.

**Step 2** The `_transfer` function does not check the state of `tradingOpen`, allowing the transfer operation to proceed even if `tradingOpen` is false.

**Step 3** The transfer operation is completed, potentially leading to unauthorized asset transfers.

If the `tradingOpen` status is not checked, then it may be possible for a user to perform a transfer operation even though the transaction has not been allowed. This may lead to unauthorized transactions, which may lead to improper flow of funds, or may even be exploited by a malicious user who may use this vulnerability to attack and cause loss of funds.

In addition, in the constructor, the code mentions transaction limits (`limited`, `maxHoldingAmount`, `minHoldingAmount`), but these transaction limits are not used in the actual implementation of the contract. If the transaction limits (e.g., maxHoldingAmount and minHoldingAmount) are not implemented, then it may result in some non-compliant transactions occurring. For example, some users may hold more than the specified maximum number of tokens, which may lead to an uneven distribution of tokens, affecting the stability and fairness of tokens. In addition, the absence of a minimum holding limit may lead to a large number of small transactions, which may increase congestion and transaction costs in the network.

## Conclusion

This incorrect access control vulnerability can lead to unauthorized transfers when trading is not permitted. This can result in unexpected behavior and potential loss of assets. The contract should implement appropriate checks on variables such as `tradingOpen` before allowing transfer operations to proceed.
